# Quest 04. OOP의 기본

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍에 대해 알아볼 예정입니다.

## Topics
* 객체지향 프로그래밍
  * 프로토타입 기반 객체지향 프로그래밍
  * 자바스크립트 클래스
    * 생성자
    * 멤버 함수
    * 멤버 변수
  * 정보의 은폐
  * 다형성
* 코드의 재사용

## Resources
* [MDN - Classes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
* [MDN - Inheritance and the prototype chain](https://developer.mozilla.org/ko/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
* [MDN - Inheritance](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Inheritance)
* [Polymorphism](https://medium.com/@viktor.kukurba/object-oriented-programming-in-javascript-3-polymorphism-fb564c9f1ce8)
* [Class Composition](https://alligator.io/js/class-composition/)
* [Inheritance vs Composition](https://woowacourse.github.io/javable/post/2020-05-18-inheritance-vs-composition/)

## Checklist
* 객체지향 프로그래밍은 무엇일까요?
  * 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식
  * 프로그램 설계방법론의 일종으로 명령형 프로그래밍에 속한다. 

  * `#`로 시작하는 프라이빗 필드는 왜 필요한 것일까요? 정보를 은폐(encapsulation)하면 어떤 장점이 있을까요?
    * #로 시작하는 프라이빗 필드는 객체지향 프로그래밍에서 캡슐화를 구현하기 위한 기능입니다. 
    이러한 필드는 클래스 내부에서만 접근 가능하며, 클래스 외부에서는 접근할 수 없습니다. 
    이를 통해 정보 은폐를 구현할 수 있습니다.

    * 정보 은폐의 장점
      * 보안 강화: 프라이빗 필드를 사용하여 객체의 상태를 보호하면, 
      클래스의 사용자가 객체의 내부 데이터를 무단으로 수정하거나 조작하는 것을 방지할 수 있습니다. 
      이는 보안 강화에 도움을 줄 수 있습니다.

      * 오류 방지: 캡슐화를 사용하면 클래스 외부에서 객체의 내부 구현 세부사항에 대한 접근을 제한함으로써, 
      객체의 일관성을 유지할 수 있습니다. 이로 인해 오류를 방지하고, 코드의 신뢰성을 높일 수 있습니다.

      * 코드 유지보수의 용이성: 캡슐화를 사용하면 내부 구현의 변경에 대한 영향을 최소화할 수 있습니다. 
      내부 구현이 변경되더라도 클래스 외부에서는 변경된 내용을 알 필요가 없으므로, 코드의 유지보수를 더욱 쉽게 할 수 있습니다.

      * 인터페이스 제공: 캡슐화를 사용하면 객체의 내부 구현과 외부 인터페이스를 분리할 수 있습니다. 
      이는 객체의 사용자에게 필요한 인터페이스를 제공하면서도 내부 구현을 숨길 수 있습니다. 
      이는 클래스의 사용성을 높여줍니다.

  * 다형성이란 무엇인가요? 다형성은 어떻게 코드 구조의 정리를 도와주나요?

    * 다형성이란? 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질을 의미합니다.
      
      * 어떻게 코드구조의 정리를 도와줄까?
        * 상속을 사용하여 여러 클래스에서 공통적으로 사용되는 코드를 부모 클래스에 작성하고, 
        자식 클래스에서 필요한 부분만 재정의함으로써 중복을 제거할 수 있습니다. 
        이를 통해 코드의 유지보수성을 높일 수 있습니다.
        * 매서드 오버라이딩: 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하여 사용하는 것을 말합니다
        * 매서드 오버로딩: 같은 이름을 가진 메서드를 매개변수의 타입이나 개수에 따라 다르게 구현하는 것을 말합니다. 
        이를 통해 다양한 타입의 매개변수를 받을 수 있으며, 코드의 재사용성을 높일 수 있습니다.


  * 상속이란 무엇인가요? 상속을 할 때의 장점과 단점은 무엇인가요?

    * 상속이란: 기존의 클래스를 재정의하여 새로운 클래스를 작성하는 것을 말합니다.
    -> 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능을 간편하게 사용할 수 있도록 하는 것.
    * is-a 관계는 상속을 통해 표현되는 관계로, "A는 B의 일종이다"라는 의미입니다.

    * (+): 코드의 재사용성이 높아지짐(코드 중복을 줄일 수 있다), 
    * (+): 코드의 확장성이 높아진다(부모의 쿨래스 기능을 활용하거나 새롭게 추가하여서 확장이 가능), 
    * (+): 객체지향에서의 다형성을 구현 할 수 있다. 
    ---
    * (-): 클래스간의 강한 결합성을 유발한다. -> 부모 클래스에 강하게 의지하게되므로 부모클래스를 수정하게 되면 자식클래스에 큰 영향을 줄 수 있다. 
    * (-): 상속 구조가 복잡해질수록 코드의 가독성이 떨어집니다. 다중 상속이 허용되는 언어에서는 다중 상속으로 인해 더욱 복잡한 상속 구조가 형성될 수 있습니다. 

 참고: https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95


  * OOP의 합성(Composition)이란 무엇인가요? 합성이 상속에 비해 가지는 장점은 무엇일까요?
    * 객체지행 프로그래밍에서의 합성이란? : 
    객체가 다른 객체를 포함하는 것을 의미합니다. 즉, 객체 안에 다른 객체를 변수로 갖고, 이를 활용하여 기능을 구현하는 방식입니다.

    * 합성을 통해 표현되는 관계인 has-a 관계("A는 B를 가지고 있다")를 이용해 객체 간의 결합도를 낮추고 클래스 간의 관계를 더 명확하게 나타낼 수 있습니다.
     * (예시) 자동차 클래스에서 엔진을 상속받는 것이 아닌 변수로 가져옴으로 수정사항이 발생했을 때 영향력을 줄일 수 있다.

* 자바스크립트의 클래스는 어떻게 정의할까요?
  * 1.  `class` 선언을 이용하는 방법이 있다.
  
  ``` 
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
  
    sayHello() {
      console.log(`안녕하세요. 제 이름은 ${this.name}입니다.`);
    }
  }
  
  ```
  * 코드 해석: 위 예시에서 Person은 클래스 이름입니다. 
  constructor 메서드는 객체를 생성할 때 호출되며, this 키워드를 사용하여 객체의 필드를 초기화합니다.
  sayHello 메서드는 객체의 메서드로, console.log를 사용하여 name 필드를 출력하는 메시지를 출력합니다.


  * 프로토타입 기반의 객체지향 프로그래밍은 무엇일까요?
    
    * 프로토타입 기반의 객체지향 프로그래밍은 클래스를 사용하지 않고, 객체를 프로토타입으로부터 생성하는 방식의 객체지향 프로그래밍입니다.
    이 방식은 자바스크립트를 비롯한 일부 프로그래밍 언어에서 사용됩니다.


  * 자바스크립트의 클래스는 이전의 프로토타입 기반의 객체지향 구현과 어떤 관계를 가지고 있나요?
   *  ES6 이전의 자바스크립트에서는 class 키워드가 없어서 객체를 생성할 때 별도의 내부 생성자 없이 바로 객체를 생성하였고, 이에 따른 속성이나 행동 값들을 부여했습니다.
      ES6 이후 생긴 class에서는 constructor 생성자를 통해 정의해줄 수 있고, 외부 생성자인 new를 통해 class를 생성하거나 상속받을 수 있습니다.

참고: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85_%EB%A9%94%EC%84%9C%EB%93%9C

## Quest
* 웹 상에서 동작하는 간단한 바탕화면 시스템을 만들 예정입니다.
* 요구사항은 다음과 같습니다:
  * 아이콘은 폴더와 일반 아이콘, 두 가지의 종류가 있습니다.
  * 아이콘들을 드래그를 통해 움직일 수 있어야 합니다.
  * 폴더 아이콘은 더블클릭하면 해당 폴더가 창으로 열리며, 열린 폴더의 창 역시 드래그를 통해 움직일 수 있어야 합니다.
  * 바탕화면의 생성자를 통해 처음에 생겨날 아이콘과 폴더의 개수를 받을 수 있습니다.
  * 여러 개의 바탕화면을 각각 다른 DOM 엘리먼트에서 동시에 운영할 수 있습니다.
  * Drag & Drop API를 사용하지 말고, 실제 마우스 이벤트(mouseover, mousedown, mouseout 등)를 사용하여 구현해 보세요!

## Advanced
* 객체지향의 역사는 어떻게 될까요?
* Smalltalk, Java, Go, Kotlin 등의 언어들로 넘어오면서 객체지향 패러다임 측면에서 어떤 발전이 있었을까요?
